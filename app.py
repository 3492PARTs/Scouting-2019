import math

from flask import Flask, render_template, request, redirect, url_for, Response
from flask_wtf import FlaskForm
from peewee import *
from flask_mail import Mail
from flask_sqlalchemy import SQLAlchemy
from flask_user import login_required, roles_required, UserManager, UserMixin, SQLAlchemyAdapter, current_user, \
    user_registered, emails
from flask_user.forms import RegisterForm
from wtforms import StringField, FieldList
from flask_wtf import FlaskForm
from peewee import DoesNotExist
from playhouse.flask_utils import object_list
from wtforms import SelectField, SubmitField, RadioField
from wtforms import StringField, FieldList
from wtforms.validators import DataRequired
import sqlalchemy.exc
import models as db
import query
from eventID import eventID

app = Flask(__name__)
app.config['SECRET_KEY'] = 'thisisasecret'
app.config[
    'SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://elgyqslrczcdhpme:kdfd5rqRVKPdyWzmuym3jh4dZVvdEZphefNuZnw3mFkccxsqD2UZxJachbmi4mm5@f79d1040-d58c-4b2d-a431-a88d017b1284.mysql.sequelizer.com/dbf79d1040d58c4b2da431a88d017b1284'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['CSRF_ENABLED'] = True
app.config['USER_APP_NAME'] = 'Passion'
app.config['USER_AFTER_REGISTER_ENDPOINT'] = 'user.login'
app.config.from_pyfile('config.cfg')
# Setup Flask-User

db_alchemy = SQLAlchemy(app)
mail = Mail(app)


class User(db_alchemy.Model, UserMixin):
    id = db_alchemy.Column('user_id', db_alchemy.BigInteger, primary_key=True)

    # User authentication information
    username = db_alchemy.Column(db_alchemy.String(50), nullable=False, unique=True)
    password = db_alchemy.Column(db_alchemy.String(255), nullable=False, server_default='')

    # User email information
    email = db_alchemy.Column(db_alchemy.String(255), nullable=False, unique=True)
    confirmed_at = db_alchemy.Column(db_alchemy.DateTime())

    # User information
    active = db_alchemy.Column(db_alchemy.Boolean(), nullable=False, server_default='0')
    first_name = db_alchemy.Column(db_alchemy.String(100), nullable=False, server_default='')
    last_name = db_alchemy.Column(db_alchemy.String(100), nullable=False, server_default='')

    # Relationships
    roles = db_alchemy.relationship('Role', secondary='user_roles',
                                    backref=db_alchemy.backref('users', lazy='dynamic'))

    def is_active(self):
        return self.active

    def is_in_role(self, r):
        role_nm = db_alchemy.session.query(Role.name).join(UserRoles, (Role.id == UserRoles.role_id) & (
                UserRoles.user_id == self.id)).all()
        rs = False
        for rn in role_nm:
            if r == rn[0]:
                rs = True
        return rs


# Define the Role data model
class Role(db_alchemy.Model):
    id = db_alchemy.Column('role_id', db_alchemy.BigInteger(), primary_key=True)
    name = db_alchemy.Column('role_nm', db_alchemy.String(50), unique=True)


# Define the UserRoles data model
class UserRoles(db_alchemy.Model):
    id = db_alchemy.Column('user_role_id', db_alchemy.BigInteger(), primary_key=True)
    user_id = db_alchemy.Column(db_alchemy.Integer(), db_alchemy.ForeignKey('user.user_id', ondelete='CASCADE'))
    role_id = db_alchemy.Column(db_alchemy.Integer(), db_alchemy.ForeignKey('role.role_id', ondelete='CASCADE'))


class MyRegisterForm(RegisterForm):
    first_name = StringField('First Name', validators=[DataRequired('First name is required')])
    last_name = StringField('Last Name')


# Setup Flask-User
db_alchemy_adapter = SQLAlchemyAdapter(db_alchemy, UserClass=User)  # Register the User model
user_manager = UserManager(db_alchemy_adapter, app, register_form=MyRegisterForm)  # Initialize Flask-User

event = eventID()


# This hook ensures that a connection is opened to handle any queries
# generated by the request.
@app.before_request
def _db_connect():
    if db.db.is_closed():
        db.db.connect()


# This hook ensures that the connection is closed when we've finished
# processing the request.
@app.teardown_request
def _db_close(exc):
    if not db.db.is_closed():
        db.db.close()


# This hook ensures that a user is given a role when they sign up
# new user registered
@user_registered.connect_via(app)
def _after_register_hook(sender, user, **extra):
    role = Role.query.filter_by(name="user").first()
    user_role = UserRoles(user_id=user.id, role_id=role.id)
    db_alchemy.session.add(user_role)
    db_alchemy.session.commit()


@app.errorhandler(sqlalchemy.exc.OperationalError)
def handle_bad_request(e):
    return redirect(request.path)


@app.route('/', methods=['GET', 'POST'])
@login_required
def index():
    events = db.event.select().order_by(db.event.event_id.asc()).tuples()
    events = list(events)

    if event.get_event_id() == -1 or request.form.get('event', '') != '':
        event_id = request.form.get('event', '')
        event.set_event_id(event_id)
    else:
        event_id = event.get_event_id()

    return render_template('index.html', events=events, event_id=event_id)


@app.route('/field')
@login_required
def field():
    teams = db.team.select(db.team.team_no, db.team.team_nm).join(db.event_team_xref, JOIN_INNER, (
            db.team.team_no == db.event_team_xref.team_no) & (db.event_team_xref.event == event.get_event_id())).order_by(
        db.team.team_no.asc()).tuples()
    teams = list(teams)
    return render_template('field.html', teams=teams)


@app.route('/field-submit', methods=['POST'])
@login_required
def field_submit():
    match = db.robot_match(event=event.get_event_id(),
                           team_no=request.form.get('team-no', None),
                           sandstorm=request.form.get('sand-storm', ''),
                           st_lvl=request.form.get('lv', ''),
                           pre_cargo_hp=request.form.get('pre-cargo-hp', ''),
                           pre_cargo_c=request.form.get('pre-cargo-c', ''),
                           pre_rocket_hp=request.form.get('pre-rocket-hp', ''),
                           pre_rocket_c=request.form.get('pre-rocket-c', ''),
                           auto_cargo_hp=request.form.get('auto-cargo-hp', ''),
                           auto_cargo_c=request.form.get('auto-cargo-c', ''),
                           auto_rocket_hp=request.form.get('auto-rocket-hp', ''),
                           auto_rocket_c=request.form.get('auto-rocket-c', ''),
                           teleop_cargo_hp=request.form.get('teleop-cargo-hp', ''),
                           teleop_cargo_c=request.form.get('teleop-cargo-c', ''),
                           teleop_rocket_hp=request.form.get('teleop-rocket-hp', ''),
                           teleop_rocket_c=request.form.get('teleop-rocket-c', ''),
                           lv_climb=request.form.get('lv-climb', ''),
                           comments=request.form.get('comments', '').replace(",", "."))

    match.save()

    return redirect(url_for('field'))


@app.route('/download')
@login_required
def download():
    if valid:
        data = db.match.select(db.match.event, db.match.team_no, db.match.scout, db.match.auto_move,
                               db.match.auto_switch_cubes,
                               db.match.auto_scale_cubes, db.match.auto_comm, db.match.match_no,
                               db.match.tele_switch_cubes,
                               db.match.tele_scale_cubes, db.match.hang, db.match.tele_comm, db.match.rate).where(
            db.match.event == event).tuples()
        data = list(data)
        csv = ""
        for dp in data:
            csv += str(dp)[1:-1] + "\n"
        return Response(
            csv,
            mimetype="text/csv",
            headers={"Content-disposition": "attachment; filename=dump.csv"})
    else:
        return redirect(url_for('index'))


@app.route('/wipe')
@roles_required('admin')
def wipe():
    if valid:
        matches = db.match.delete().where(db.match.event == event)
        matches.execute()  # Returns the number of rows deleted.
        return redirect(url_for('index'))
    else:
        return redirect(url_for('index'))


@app.route('/upload', methods=['POST'])
@roles_required('admin')
def upload():
    if valid:
        csv = request.files.get('upload', None)
        print(csv)

        line = csv.readline()
        while line:
            print(line)
            dp = line[:-1].decode("utf-8").split(",")

            match = db.match(event=dp[0].strip().replace("'", ""), team_no=dp[1].strip().replace("'", ""),
                             scout=dp[2].strip().replace("'", ""), auto_move=dp[3].strip().replace("'", ""),
                             auto_switch_cubes=dp[4].strip().replace("'", ""),
                             auto_scale_cubes=dp[5].strip().replace("'", ""), auto_comm=dp[6].strip().replace("'", ""),
                             match_no=dp[7].strip().replace("'", ""),
                             tele_switch_cubes=dp[8].strip().replace("'", ""),
                             tele_scale_cubes=dp[9].strip().replace("'", ""),
                             hang=dp[10].strip().replace("'", ""), tele_comm=dp[11].strip().replace("'", ""),
                             rate=dp[12].strip().replace("'", ""))
            match.save()

            line = csv.readline()

        csv.close()

    return redirect(url_for('index'))


@app.route('/view')
@login_required
def view():
    matches = db.robot_match.select(
        db.robot_match.team_no,
        db.robot_match.sandstorm,
        db.robot_match.st_lvl,
        db.robot_match.pre_cargo_hp,
        db.robot_match.pre_cargo_c,
        db.robot_match.pre_rocket_hp,
        db.robot_match.pre_rocket_c,
        db.robot_match.auto_cargo_hp,
        db.robot_match.auto_cargo_c,
        db.robot_match.auto_rocket_hp,
        db.robot_match.auto_rocket_c,
        db.robot_match.teleop_cargo_hp,
        db.robot_match.teleop_cargo_c,
        db.robot_match.teleop_rocket_hp,
        db.robot_match.teleop_rocket_c,
        db.robot_match.lv_climb,
        db.robot_match.comments
    ).where(db.robot_match.event == event.get_event_id()) \
        .order_by(db.robot_match.team_no.asc()).tuples()
    matches = list(matches)
    cols = ['Team', 'Sandstorm', 'Start LV', 'Pre CShip HP', 'Pre CShip C', 'Pre Rocket HP', 'Pre Rocket C',
            'Auto CShip HP', 'Auto CShip C', 'Auto Rocket HP', 'Auto rocket C', 'Teleop CShip HP', 'Teleop CShip C',
            'Teleop Rocket HP', 'Teleop Rocket C', 'Climb LV', 'Comments']

    return render_template('view.html', cols=cols, matches=matches)


@app.route('/pit')
@login_required
def pit():
    done = db.team.select(db.team.team_no, db.team.team_nm).where(db.pit.select(fn.Count(db.pit.team_no)).where(
        (db.pit.team_no == db.team.team_no) & (db.pit.event == event.get_event_id())) != 0)

    todo = db.team.select(db.team.team_no, db.team.team_nm).where(db.pit.select(fn.Count(db.pit.team_no)).where(
        (db.pit.team_no == db.team.team_no) & (db.pit.event == event.get_event_id())) == 0)

    return render_template('pit.html', todo=todo, done=done)


@app.route('/pit-scout')
@login_required
def pit_scout():
    team_no = request.args.get('team_no', None)

    team = db.team.select().where(db.team.team_no == team_no)
    team = list(team.tuples())[0]

    print(team)

    results = db.pit.select(db.pit.drivetrain, db.pit.speed, db.pit.fabrication,
                            db.pit.auto, db.pit.teleop, db.pit.ball_mech,
                            db.pit.hatch_mech, db.pit.cargo_ship, db.pit.rocket,
                            db.pit.climb, db.pit.strategy).where(
        (db.pit.team_no == team_no) & (db.pit.event == event.get_event_id()))

    try:
        results = list(results.tuples())[0]
    except IndexError:
        results = []

    return render_template('pit_scout.html', team=team, results=results)


@app.route('/pit-submit', methods=['POST'])
@login_required
def pit_submit():
    team_no = request.form.get('team_no')
    drivetrain = request.form.get('drive-train', "")
    fast = request.form.get('fast', '')
    held = request.form.get('held', '')
    auto = request.form.get('auto', '')
    teleop = request.form.get('teleop', '')
    cargo_mech = request.form.get('cargo-mech', '')
    hatch_mech = request.form.get('hatch-mech', '')
    cargo_ship = request.form.get('cargo-ship', '')
    rocket = request.form.get('rocket', '')
    climb = request.form.get('climb', '')
    strat = request.form.get('strat', '')

    try:
        pit_res = db.pit.get((db.pit.team_no == team_no) & (db.pit.event == event))
        pit_res.drivetrain = drivetrain
        pit_res.speed = fast
        pit_res.climb = climb
        pit_res.fabrication = held
        pit_res.rocket = rocket
        pit_res.auto = auto
        pit_res.teleop = teleop
        pit_res.cargo_ship = cargo_ship
        pit_res.harch_mech = hatch_mech
        pit_res.ball_mech = cargo_mech
        pit_res.strategy = strat

    except DoesNotExist:
        pit_res = db.pit(team_no=team_no, event_id=event.get_event_id(), drivetrain=drivetrain,
                         speed=fast, climb=climb, fabrication=held,
                         rocket=rocket, auto=auto, teleop=teleop,
                         cargo_ship=cargo_ship, hatch_mech=hatch_mech, ball_mech=cargo_mech,
                         strategy=strat)

    pit_res.save()

    return redirect(url_for('pit'))


@app.route('/pit-view', methods=['GET', 'POST'])
@login_required
def pit_view():
    teams = db.team.select().join(db.event_team_xref, JOIN_INNER,
                                  (db.team.team_no == db.event_team_xref.team_no) & (
                                          db.event_team_xref.event == event.get_event_id())).order_by(
        db.team.team_no.asc()).tuples()
    teams = list(teams)

    data_with = []
    data_against = []

    if request.method == 'POST':
        team_one = request.form.get('team-one', None)
        team_two = request.form.get('team-two', None)
        team_three = request.form.get('team-three', None)

        team_wone = request.form.get('team-wone', None)
        team_wtwo = request.form.get('team-wtwo', None)

        if team_one is not None:
            team_one = db.pit.select(db.pit.team_no, db.pit.drivetrain, db.pit.speed, db.pit.fabrication,
                                     db.pit.auto, db.pit.teleop, db.pit.ball_mech,
                                     db.pit.hatch_mech, db.pit.cargo_ship, db.pit.rocket,
                                     db.pit.climb, db.pit.strategy, db.team.team_nm).where(
                (db.pit.team_no == team_one) & (db.pit.event == event.get_event_id())).join(db.team, JOIN_INNER,
                                                                             db.team.team_no == db.pit.team_no)
            print(list(team_one.tuples()))
            data_against.append(list(team_one.tuples())[0])
        if team_two is not None:
            team_two = db.pit.select(db.pit.team_no, db.pit.drivetrain, db.pit.speed, db.pit.fabrication,
                                     db.pit.auto, db.pit.teleop, db.pit.ball_mech,
                                     db.pit.hatch_mech, db.pit.cargo_ship, db.pit.rocket,
                                     db.pit.climb, db.pit.strategy, db.team.team_nm).where(
                (db.pit.team_no == team_two) & (db.pit.event == event.get_event_id())).join(db.team, JOIN_INNER,
                                                                             db.team.team_no == db.pit.team_no)
            data_against.append(list(team_two.tuples())[0])
        if team_three is not None:
            team_three = db.pit.select(db.pit.team_no, db.pit.drivetrain, db.pit.speed, db.pit.fabrication,
                                       db.pit.auto, db.pit.teleop, db.pit.ball_mech,
                                       db.pit.hatch_mech, db.pit.cargo_ship, db.pit.rocket,
                                       db.pit.climb, db.pit.strategy, db.team.team_nm).where(
                (db.pit.team_no == team_three) & (db.pit.event == event.get_event_id())).join(db.team, JOIN_INNER,
                                                                               db.team.team_no == db.pit.team_no)
            data_against.append(list(team_three.tuples())[0])

        if team_wone is not None:
            team_wone = db.pit.select(db.pit.team_no, db.pit.drivetrain, db.pit.speed, db.pit.fabrication,
                                      db.pit.auto, db.pit.teleop, db.pit.ball_mech,
                                      db.pit.hatch_mech, db.pit.cargo_ship, db.pit.rocket,
                                      db.pit.climb, db.pit.strategy, db.team.team_nm).where(
                (db.pit.team_no == team_wone) & (db.pit.event == event.get_event_id())).join(db.team, JOIN_INNER,
                                                                              db.team.team_no == db.pit.team_no)
            data_with.append(list(team_wone.tuples())[0])
        if team_wtwo is not None:
            team_wtwo = db.pit.select(db.pit.team_no, db.pit.drivetrain, db.pit.speed, db.pit.fabrication,
                                      db.pit.auto, db.pit.teleop, db.pit.ball_mech,
                                      db.pit.hatch_mech, db.pit.cargo_ship, db.pit.rocket,
                                      db.pit.climb, db.pit.strategy, db.team.team_nm).where(
                (db.pit.team_no == team_wtwo) & (db.pit.event == event.get_event_id())).join(db.team, JOIN_INNER,
                                                                              db.team.team_no == db.pit.team_no)
            data_with.append(list(team_wtwo.tuples())[0])

        print(data_against)
        print(data_with)

    return render_template('pit_view.html', teams=teams, data_against=data_against, data_with=data_with)


##############ADMIN

@app.route('/admin', methods=['GET'])
@roles_required('admin')
def admin():
    users = db.user.select(db.user.user_id, db.user.username, db.user.email, db.user.first_name, db.user.last_name,
                           db.user.confirmed_at, db.user.active)

    for u in users:
        for r in u.user_roles_set:
            print(r.role.role_id)
            print(r.role.role_nm)

    return render_template('admin/admin.html', users=users)


@app.route('/admin-edit/<int:user_id>', methods=['GET', 'POST'])
@roles_required('admin')
def edit(user_id):
    if request.method == 'POST':

        return redirect(admin)
    else:
        user = db.user.get(db.user.user_id == user_id)

        roles = list(db.role.select().where(
            db.role.role_id.not_in(
                db.user_roles.select(db.user_roles.role).where(
                    db.user_roles.user == user.user_id
                )
            )
        ).tuples())

        user_roles = []
        for r in user.user_roles_set:
            user_roles.append([r.role.role_id, r.role.role_nm])

        print(user_roles)
        print(roles)

        return render_template('admin/edit.html', user=user, user_roles=user_roles, roles=roles)


@app.route('/delete')
@roles_required('admin')
def delete():
    user_id = request.args.get('u_id')
    if int(user_id) == int(current_user.id):
        return redirect(url_for('admin'))
    querydb.softDeleteUser(user_id)
    return redirect(url_for('admin'))


if __name__ == '__main__':
    app.run(debug=True)
